<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>The Case for Learned Index Structures | Yuanxinhang's Blog</title><meta name="keywords" content="索引生成,哈希"><meta name="author" content="Xinhang Yuan"><meta name="copyright" content="Xinhang Yuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="The Case for Learned Index Structures | Papers With Code 文章解读Introduction当我们需要查询数据库中的某条数据时，这数据在数据库中的 index 就是我们想要的答案，数据库对我们的重要性不言而喻。 现有的索引结构中，B+ 树对于范围查询无疑是最佳的，哈希表对于 kv 查询是最合适的，而布隆过滤器更多用于查询 key 是否存在于某个">
<meta property="og:type" content="article">
<meta property="og:title" content="The Case for Learned Index Structures">
<meta property="og:url" content="http://example.com/2021/12/03/The-Case-for-Learned-Index-Structures/index.html">
<meta property="og:site_name" content="Yuanxinhang&#39;s Blog">
<meta property="og:description" content="The Case for Learned Index Structures | Papers With Code 文章解读Introduction当我们需要查询数据库中的某条数据时，这数据在数据库中的 index 就是我们想要的答案，数据库对我们的重要性不言而喻。 现有的索引结构中，B+ 树对于范围查询无疑是最佳的，哈希表对于 kv 查询是最合适的，而布隆过滤器更多用于查询 key 是否存在于某个">
<meta property="og:locale">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-12-03T11:43:44.000Z">
<meta property="article:modified_time" content="2021-12-05T10:19:10.337Z">
<meta property="article:author" content="Xinhang Yuan">
<meta property="article:tag" content="索引生成">
<meta property="article:tag" content="哈希">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/03/The-Case-for-Learned-Index-Structures/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'The Case for Learned Index Structures',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-05 18:19:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yuanxinhang's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">The Case for Learned Index Structures</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-12-03T11:43:44.000Z" title="Created 2021-12-03 19:43:44">2021-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-12-05T10:19:10.337Z" title="Updated 2021-12-05 18:19:10">2021-12-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="The Case for Learned Index Structures"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://paperswithcode.com/paper/the-case-for-learned-index-structures">The Case for Learned Index Structures | Papers With Code</a></p>
<h2 id="文章解读"><a href="#文章解读" class="headerlink" title="文章解读"></a>文章解读</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>当我们需要查询数据库中的某条数据时，这数据在数据库中的 index 就是我们想要的答案，数据库对我们的重要性不言而喻。</p>
<p>现有的索引结构中，B+ 树对于范围查询无疑是最佳的，哈希表对于 kv 查询是最合适的，而布隆过滤器更多用于查询 key 是否存在于某个数据集中，但是这些索引结构的优化大多是基于数据最差的情况，并且读写相对均匀进行优化，这里作者举了一个极端的例子来说明，比如我们的数据集就是1-100M，那么这时候如果使用 B+ 树其实不是最合理的，因为 key 值本身就可以作为偏移量使用，如果使用 B+ 树的话，无疑是把 O(1) 的时间复杂度变成了 O(logn)，并且由于索引的存在，所以内存空间也会由 O(1) 变成 O(n)。换句话说，<strong>当我们了解数据分布的情况下，其实可以优化数据库的索引。</strong></p>
<p>基于这个想法，在这篇 paper 中，作者认为索引结构也可以视作模型，因为它们同样“预测”了给定 key 的 position，同时探索了数据库索引 key → value 这个过程中的 B+ 树和布隆过滤器这些传统索引结构在多大程度上可以被训练好的网络模型代替。</p>
<p>这篇 paper 主要讨论的是只读类型，但是同样也在 paper 内讨论了如何扩展到写多读少的数据库场景中，至于数据库中的一些其他操作，比如 join 等，将会是未来的一个工作方向，不在这篇 paper 的讨论范围。</p>
<h3 id="Range-Index"><a href="#Range-Index" class="headerlink" title="Range Index"></a>Range Index</h3><p>对于区间查询而言，作者认为它本身就是一个模型，给定一个 key 值的时候去预测 key index 的 position，B+ 树可以被回归树代替，而 B+ 树中的 pagesize 相当于 ML 模型中的 最大最小误差。但是我们想要用 ML 模型代替 B+ 树的时候还有一些挑战，</p>
<ol>
<li>当 B+ 树在内存中进行插入或者查找操作的时候开销是很小的</li>
<li>B+ 树可以将 key 映射到不连续的磁盘或者内存的 page 上</li>
<li>如果模型不是单调递增时，当 key 不存在于 set 中，模型可能会返回一个不在最大最小误差范围内的 position</li>
</ol>
<p>但是针对区间查找，使用模型代替 B+ 树依然会有很多的好处，这里作者举了一个和 introduction 中相似的例子来说明，使用 ML 模型代替 B+ 树的时候，查找操作的复杂度会从 O(log n) 变成常数复杂度。<strong>所以这里关键的挑战就在于如何根据模型的精度平衡模型的复杂度。</strong></p>
<h4 id="Range-Index-模型抽象为-CDF"><a href="#Range-Index-模型抽象为-CDF" class="headerlink" title="Range Index 模型抽象为 CDF"></a>Range Index 模型抽象为 CDF</h4><p>将 index 视作模型的时候，key 作为输入，对应 key 的记录的 position 作为预测结果，对于点查询，记录的顺序是无所谓的，但是对于区间查询而言，数据必须是有序的，这样才能有效的查到对应的记录。这样的话我们就观察到一个非常有趣的现象，预测给定有序的数组内 key 的 position 近似累计分布函数（CDF），我们可以建模数据的 CDF 来预测数据的 position，</p>
<script type="math/tex; mode=display">
p = F(Key)*N</script><p>其中，p 是位置的估计，F(Key) 是估计的 CDF，用来估计一个 x ≤ key 的概率，即P(x≤Key)，N 是 key 的个数。观察新的数据集会有一些有趣的发现，</p>
<ol>
<li>B 树通过构建一颗回归树来学习数据分布，线性回归模型可以通过最小化线性方程的方差来学习数据分布</li>
<li>学习 CDF 分布我们可以受益于过去多年的研究</li>
<li>学习 CDF 对于优化其他类型的索引结构和算法起着关键作用，会在这篇 paper 的后面讲到</li>
</ol>
<p>接着作者尝试使用 200 M 的 web 服务日志记录中的时间戳作为数据集来训练模型，2层宽度为32的全连接的神经网络使用 ReLU 作为激活函数，时间戳作为输入，position 作为 label，使用 TensorFlow 和 Python 进行模型训练，大约需要花费 80000 纳秒进行模型的训练，查询几乎不花费时间，作为对比，B 树查找同样的数据大约只需要 300 纳秒，相差两个数量级，整个 key 空间查找大约快2-3倍，可能是由以下原因导致的，</p>
<ol>
<li>TensorFlow 更适用于大的模型，尤其是使用 Python 作为前端</li>
<li>最后一公里的精度问题，虽然整体数据分布看上去接近于 CDF，很平滑，但是放大某个点的数据分布的时候，我们会发现数据分布很不规则，所以如何解决最后一公里的精度问题就十分重要</li>
<li>经典的机器学习问题，最终的目标是想要减小平均误差，但是我们查找索引，是希望获得最佳预测，最终是期望找到 key 的真实的 position</li>
<li>B+ 树十分高效，因为顶层的节点也就是索引都在缓存中，但是其他模型无法利用缓存的高效性，比如如果我们使用神经网络，那么需要使用所有的权重来预测最终的结果，权重如果在内存中的话开销就会比较大</li>
</ol>
<h3 id="The-RM-Index"><a href="#The-RM-Index" class="headerlink" title="The RM Index"></a>The RM Index</h3><p>为了解决 ML 模型替代 B+ 树的最后一公里精度问题，paper 中提出了 LIF 和递归模型索引，主要使用简单的全连接神经网络。</p>
<h4 id="The-Learning-Index-Framework"><a href="#The-Learning-Index-Framework" class="headerlink" title="The Learning Index Framework"></a>The Learning Index Framework</h4><p>LIF 可以看做一个索引综合系统，给定一个索引规范，LIF 可以生成不同的索引配置，优化并且自动测试，可以即时的学习简单的模型，也可以依赖 TensorFlow 获取复杂的模型，但是不使用 TensorFlow 进行预测，并且当给定一个使用 TensorFlow 训练好的模型 LIF 可以自动提取权重，并根据规范生成搞笑的索引结构。使用 XLA 的 TensorFlow 可以支持代码编译，但是主要用于大型模型，相比之下 LIF 专注于小型模型，所以必须减少用于管理大型模型的许多不必要的开销，引用21中的已经展示了如何消除 Spark 运行时间不必要的开销，目前 LIF 计算简单的模型可以仅在 30 纳秒内完成。</p>
<p>这一部分内容主要用于解决当数据分布改变时需要重新训练模型的时间开销。</p>
<h4 id="The-Recursive-Model-Index"><a href="#The-Recursive-Model-Index" class="headerlink" title="The Recursive Model Index"></a>The Recursive Model Index</h4><p>为了解决最后一公里精度的问题，paper 中提出了递归回归模型。使用单个模型将误差从100M 减少到百数量级是很困难的，但是从100M 将误差减小到10k 是很容易的，使用模型代替 B 树的前两层，带来的精度增益就是100*100=10000，同样，将误差从1000减小到100也很容易，因为模型只需要关注数据的一个子集即可。</p>
<p>因此，paper 提出了递归回归模型，如图，</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4970205-9476d2a6100450b2.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>每一层中 key 作为输入，并基于此挑选出另一个模型，直到最后一层预测最终的索引位置。</p>
<p>这种模型结构的好处是，</p>
<ol>
<li>很容易学习整体数据分布</li>
<li>将整个空间分割为更小的子区间，每个子区间都类似于一个 B 树或者决策树，更容易去解决最后一公里的精度问题</li>
<li>不同的层之间不需要搜索，比如 model 1.1 输出的 y 是一个偏移量，可以直接用于挑选下一层的模型</li>
</ol>
<p>递归模型索引的另一个优点是能够使用混合模型，比如顶层，可能使用 ReLU 的神经网络是最好的，因为可以学习大范围的复杂数据分布，但是下层模型可能使用简单的线性回归模型就可以了，因为时间和空间的开销都相对更小一些，同时，如果数据分布很难学习，我们甚至可以设置阈值，在最终阶段使用传统 B 树。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4970205-80e92630e20bba66.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>4-10行实现了基于顶点模型进行训练，并将范围内的 key 存入；11-14行，根据阈值决定是否使用 B 树代替模型。</p>
<h4 id="搜索策略"><a href="#搜索策略" class="headerlink" title="搜索策略"></a>搜索策略</h4><p>paper 中提出了三种搜索策略，</p>
<ol>
<li>模型二分搜索：默认搜索策略，类似传统二分搜索，不同点在于初始的中间点被设置为模型预测的结果</li>
<li>Biased Search：基于二分搜索进行修改，新的中间点基于最后一层模型的标准偏差σ设置，比如，当 key 比中间节点大的时候，middle = min(middle+σ, (middle+right)/2)</li>
<li>Biased Quaternary Search：同时查找三个点，pos-σ，pos，pos+σ，需要 CPU 可以从主存中并行获取多个数据地址</li>
</ol>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>使用的数据集</p>
<ol>
<li>Web log</li>
<li>Map</li>
<li>合成数据集</li>
</ol>
<p>使用模型训练比 B 树整体上而言，不论是查询时间还是存储空间都有了不止一个数量级的降低，但是适用的数据集比较有限，比如使用 web log 的时间戳的数据集进行训练的时候，由于时间戳的分布不规则，所以基本上是上面说到的大部分依赖于 B 树的 bad case，搜索策略对于 web log 比较有效果，但是对于其他数据集而言，搜索策略的影响不大。</p>
<h3 id="Point-Index"><a href="#Point-Index" class="headerlink" title="Point Index"></a>Point Index</h3><p>对于点查询，是将 Hash Function 替换为 Model，这里的核心不在于存储，而在于减少哈希碰撞，并且减少 key 的存储空间。使用 model 替换 hash function，学习的内容和 key 和 value 本身没有关系，只是学习了 CDF 分布，因为点查询是不能保证 key 单调递增的，如果不能保证单调递增，那么 key 的分布本身也不符合 CDF 分布，当学习 CDF 足够好的时候，就会保证区分度，这样再使用 key 的大小 M 来将这个 hash 的值扩展开，这样就可以保证没有碰撞。</p>
<p>但是如果真的出现碰撞的话，处理方法和 hash function 一样，使用链表来处理。</p>
<script type="math/tex; mode=display">
h(K) = F(K) * M</script><p><img src="/2021/12/03/The-Case-for-Learned-Index-Structures/image-20211205173230927.png" alt="image-20211205173230927"></p>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>hash function 使用 model 进行替换后，查询时间没有缩短，但是 key 空间确实有效的减少了，提高了空间利用率。</p>
<h3 id="Existence-Index"><a href="#Existence-Index" class="headerlink" title="Existence Index"></a>Existence Index</h3><p>对于判断某个 key 是否存在于数据集内，目前的场景是使用布隆过滤器，但是布隆过滤器有一定的误判率，如果要提升精度减少误判率就势必要增加 bitmap。对于 hash function 来说，我们期望的 f(x) 使得不同的 key 冲突越少越好，但是对于布隆过滤器来说，我们期望存在的 key 和不存在的 key 它们在自己的 f(x) 内冲突越多越好，这样可以用更小的 bitmap 表示更多的 key，我们想要使用 ML model 代替布隆过滤器时，我们期望提供特定的假阳性，并且假阴性为0。paper 中介绍了两种学习布隆过滤器的方法，</p>
<h4 id="将布隆过滤器视作一个分类问题"><a href="#将布隆过滤器视作一个分类问题" class="headerlink" title="将布隆过滤器视作一个分类问题"></a>将布隆过滤器视作一个分类问题</h4><p>D = {(xi, yi= 1)|xi∈ K} ∪ {(xi, yi= 0)|xi∈ U}</p>
<p>我们需要训练这样一个神经网络，使得 log 损失函数最小。为了满足假阴性为0这个条件，我们创建一个溢出的布隆过滤器，根据阈值学习一个模型，当输出结果大于等于阈值的时候，我们认为这个 key 是存在于 set 中的，当小于阈值时，则去 check 溢出的布隆过滤器。</p>
<p>简单的说，就是将存在的 key 和不存在的 key 划分为两个数据集，然后融合到一个集合中进行训练，最小化一个 log 损失函数。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4970205-74b56c5988a45465.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/718/format/webp" alt="img"></p>
<h4 id="使用-model-hashes-学习布隆过滤器"><a href="#使用-model-hashes-学习布隆过滤器" class="headerlink" title="使用 model hashes 学习布隆过滤器"></a>使用 model hashes 学习布隆过滤器</h4><p>将布隆过滤器视作一个分类问题时与布隆过滤器中的散列函数本身是矛盾的，因为没有区间具有非零的 FNR，我们可以使用 f(x) 映射到 m 的位数组上，f(x) 映射范围是[0,1]，所以我们可以假设 d 如下，作用是离散化空间，</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4970205-04434c3d1460ed39.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/198/format/webp" alt="img"></p>
<p>所以我们可以使用 d(f(x)) 作为散列函数，这样可以将存在的 key 映射到 bit 的高位上，将不存在的 key 映射到 bit 的低位上。</p>
<p>f(x) ∈ [0,1]，当 key 不存在时，f(x)更接近于0，反之，更接近于1，所以 key 大多分布在高位上，non-key 大多分布在低位上。</p>
<h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><p>空间利用率确实有所提升，并且模型精度越高，占用内存越少，但没有对比数据作为支撑。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a target="_blank" rel="noopener" href="https://paperswithcode.com/paper/the-case-for-learned-index-structures#code">https://paperswithcode.com/paper/the-case-for-learned-index-structures#code</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Xinhang Yuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/03/The-Case-for-Learned-Index-Structures/">http://example.com/2021/12/03/The-Case-for-Learned-Index-Structures/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95%E7%94%9F%E6%88%90/">索引生成</a><a class="post-meta__tags" href="/tags/%E5%93%88%E5%B8%8C/">哈希</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/12/01/%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%E5%92%8CK-S%E6%A3%80%E9%AA%8C%E6%96%B0%E6%94%B9%E8%BF%9B/"><img class="next-cover" src="https://alifei00.cfp.cn/cms/image/image/d999cd1ec67d4c31beee274519e73e77.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">字节编码和K-S检验新改进</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xinhang Yuan</div><div class="author-info__description">这里是！一个热爱生活的！女孩子的Blog！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/VivianYuan12138" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E8%A7%A3%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">文章解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range-Index"><span class="toc-number">1.2.</span> <span class="toc-text">Range Index</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Range-Index-%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1%E4%B8%BA-CDF"><span class="toc-number">1.2.1.</span> <span class="toc-text">Range Index 模型抽象为 CDF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-RM-Index"><span class="toc-number">1.3.</span> <span class="toc-text">The RM Index</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Learning-Index-Framework"><span class="toc-number">1.3.1.</span> <span class="toc-text">The Learning Index Framework</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Recursive-Model-Index"><span class="toc-number">1.3.2.</span> <span class="toc-text">The Recursive Model Index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.3.</span> <span class="toc-text">搜索策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.3.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Point-Index"><span class="toc-number">1.4.</span> <span class="toc-text">Point Index</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Existence-Index"><span class="toc-number">1.5.</span> <span class="toc-text">Existence Index</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%86%E4%BD%9C%E4%B8%80%E4%B8%AA%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.1.</span> <span class="toc-text">将布隆过滤器视作一个分类问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-model-hashes-%E5%AD%A6%E4%B9%A0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用 model hashes 学习布隆过滤器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-number">1.5.3.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">代码</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/The-Case-for-Learned-Index-Structures/" title="The Case for Learned Index Structures"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The Case for Learned Index Structures"/></a><div class="content"><a class="title" href="/2021/12/03/The-Case-for-Learned-Index-Structures/" title="The Case for Learned Index Structures">The Case for Learned Index Structures</a><time datetime="2021-12-03T11:43:44.000Z" title="Created 2021-12-03 19:43:44">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%E5%92%8CK-S%E6%A3%80%E9%AA%8C%E6%96%B0%E6%94%B9%E8%BF%9B/" title="字节编码和K-S检验新改进"><img src="https://alifei00.cfp.cn/cms/image/image/d999cd1ec67d4c31beee274519e73e77.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字节编码和K-S检验新改进"/></a><div class="content"><a class="title" href="/2021/12/01/%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%E5%92%8CK-S%E6%A3%80%E9%AA%8C%E6%96%B0%E6%94%B9%E8%BF%9B/" title="字节编码和K-S检验新改进">字节编码和K-S检验新改进</a><time datetime="2021-12-01T14:36:58.000Z" title="Created 2021-12-01 22:36:58">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/24/Byte-Segment-Neural-Network-for-Network-Traffic/" title="Byte Segment Neural Network for Network Traffic"><img src="https://alifei00.cfp.cn/cms/image/image/22ab2dbf5349494ba4295b1cd556a5f6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Byte Segment Neural Network for Network Traffic"/></a><div class="content"><a class="title" href="/2021/11/24/Byte-Segment-Neural-Network-for-Network-Traffic/" title="Byte Segment Neural Network for Network Traffic">Byte Segment Neural Network for Network Traffic</a><time datetime="2021-11-24T09:37:13.000Z" title="Created 2021-11-24 17:37:13">2021-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/20/Efficient-Cyber-Attack-Detection-in-Industrial/" title="Efficient Cyber Attack Detection in Industrial Control Systems Using Lightweight Neural Networks and PCA"><img src="https://i.ibb.co/2MgPH4q/a2e71fbfb4558713f0d4e69ad2de7df2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Efficient Cyber Attack Detection in Industrial Control Systems Using Lightweight Neural Networks and PCA"/></a><div class="content"><a class="title" href="/2021/11/20/Efficient-Cyber-Attack-Detection-in-Industrial/" title="Efficient Cyber Attack Detection in Industrial Control Systems Using Lightweight Neural Networks and PCA">Efficient Cyber Attack Detection in Industrial Control Systems Using Lightweight Neural Networks and PCA</a><time datetime="2021-11-20T07:01:13.000Z" title="Created 2021-11-20 15:01:13">2021-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/18/%E5%85%B3%E4%BA%8E%E6%96%87%E6%9C%AC%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BBFGPM%E7%9A%84%E6%80%9D%E8%80%83/" title="关于文本对抗攻击FGPM的思考"><img src="https://i.ibb.co/31BFG7q/1cf17d0f033bcc029e85ad734e7f6d4f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于文本对抗攻击FGPM的思考"/></a><div class="content"><a class="title" href="/2021/11/18/%E5%85%B3%E4%BA%8E%E6%96%87%E6%9C%AC%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BBFGPM%E7%9A%84%E6%80%9D%E8%80%83/" title="关于文本对抗攻击FGPM的思考">关于文本对抗攻击FGPM的思考</a><time datetime="2021-11-18T10:21:07.000Z" title="Created 2021-11-18 18:21:07">2021-11-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Xinhang Yuan</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '83386f0d94979acb3088',
      clientSecret: '6d24a4aad81b98fe03bef8ec3d2631008a2f5285',
      repo: 'vivianyuan12138.github.io',
      owner: 'VivianYuan12138',
      admin: ['VivianYuan12138'],
      id: '1e08f8a5c8ffb90492d2878aa9a2d7c3',
      language: 'en',
      perPage: 10,
      distractionFreeMode: true,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>